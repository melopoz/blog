---
titile: Java中的位运算
tag:
  - 位运算
  - 二进制
categories: basics
date: 2021/01/01 20:46:25
updated: 2021/01/01 20:46:25
---



## Java中的位运算

`<< / >>`：算数位移，符号位不变

`>>>`：逻辑位移，忽略符号位的含义，直接将所有bit右移

比如：`-2`用8位二进制表示：`1111 1110`

**算数右移**一位得到`-1`(八位二进制：`1111 1111`)

> `1111 1110`, >>1: `0111 1111`, 保留符号位：`1111 1111`，二进制负数求值1)反码:`1000 0000`2）加1:`1000 0001`

**逻辑右移**一位得到127(八位二进制：`0111 1111`)

> `1111 1110`, >>1: `0111 1111` ，忽略第一位本应该表示的符号含义，结果变成了正数，直接计算值 2^7-1。
>
> > 如果用int类型，` -2>>1 = -1`，`-2>>>1 = 2147483647`



## 补码

> 反码：正数时，跟原码一样；负数时，原码符号位除外，其他位按位取反

> 补码：正数时，跟原码一样；负数时，反码加一

cpu只能处理加法，那减法怎么办 ？  补码相加

> 比如  3 - 8：（ 3 + -8）
>
> 3:0000 0011
>
> 8:0000 1000
>
> -8:1000 1000（第一位 符号位）
>
> > 3补:0000 0011（正整数的补码还是他本身）
> >
> > -8补:1111 1000（除符号位之外取反，然后+1）
> >
> > ​    0000 0011
> >
> > \+ 1111 1000
> >
> > =  1111 1011（不是最终结果）
> >
> > =  1000 0101 （取反+1）
> >
> > 十进制表示 ： -5

如果是 8-3

>   0000 1000（8补）
>
>   1000 0011（-3）
>
>   1111 1101（-3补）
>
> = 0000 0101（8补 + -3补）（非最终结果）
>
> 最终结果：取补码，还是 0000 0101
>
> 十进制表示：5





乘法基于加法，除法基于乘法





## 掩码 mask

掩码（Mask），通过与目标数字（flag）的按位进行与运算，达到屏蔽指定位的效果。

比如我们可以定义常量`MASK=2`，即二进制`0000 0010`，待操作数`flag=11`，即`0000 1011`，那么： flag & MASK =>

```shell
    00000010 #mask
&   00001011 #flag
    00000010 #result  相当与 用mask规定哪些是有效位（mask为1的bit是有效位）。
```

可以看到，flag除了位1外，其他都被置0了，可以看出掩码的一个作用就是保留掩码为1 的位所对应操作数的位为1，其他位清零。