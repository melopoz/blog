---
title: 缓存的数据一致性
tags:
  - 数据一致性
  - 分布式
categories: 架构
updated: 2021/04/12 20:46:25
---



现在很多项目都引入缓存以提高性能、降低数据库压力。举个例子（简单点说）就是 `mysql` + `redis`。

实现的时候无非就是把数据库和缓存中的数据都更新。如果这是一个原子性操作，啥事没有...

既然是两个操作，执行总会有先后（两个操作之间可能发生一些事情导致结果并不是你想看到的...没想到这些就是"有bug"，想到了就是"实现不了"）。

也就是有如下几种**更新策略**：（无数据库锁、单机数据库）

- 先更新cache，再更新db：肯定不行，别想了，`更新cache`成功，`更新db`失败，还是脏数据。
- 先更新db，再更新cache：如果这两个操作之间有另一个事务T2完成了（执行完`更新db`+`更新cache`），当前事务的`更新cache`就是把脏数据放到了数据库。

如果`cache未命中，从db读取`，肯定会填充cache，所以直接把cache删掉，下次从db读取的时候再填充cache就能解决上述问题。

所以有 `更新db` + `删除cache` 的组合：

- 先删除cache，再更新db：如果两个操作之间有读请求因为没有命中cache而把db的旧数据填充到了cache，相当于cache中还是脏数据。
- **先更新db，再删除cache（常用）**：起码能保证当前事务自身不会把脏数据、旧数据放到cache。

但是也会有问题：

1. 缓存已失效的情况下，查询和更新同时进行。（一般读多写少，这种情况概率极低）

   > > 缓存已过期
   >
   > T1 请求查询，缓存未命中，查询db；
   >
   > T2 请求 更新数据库，并删除cache（本来cache也是空的）；
   >
   > T1 将查询到的（旧）数据填充到cache。**导致数据不一致**

2. 读写分离的数据库架构

   > T1 更新db（更新到master，还未同步到slave），删除cache；
   >
   > T2 请求查询，从slave读取到旧数据并填充缓存。**导致数据不一致**

   如果不要求强一致性，就是用缓存的过期时间来兜底。

3. 如果**删除cache失败**（可能网络故障等等原因。如果因此就回滚db事务或者重试删除，性能下降会很严重。）

   - 回滚事务：性能下降严重
   - 重试删除cache：性能下降严重
   - 删除失败再**异步删除cache**：**折中**，保证性能的同时，争取提高数据的一致性。但是因为要引入消息队列，**增加了复杂度**。

   如果是主从架构的数据库：

   - 因为主从同步是通过binlog实现，所以可以监听binlog，binlog更新就更新缓存。

4. 删除key可能主动造成**缓存击穿**（大量请求正在访问这个key，突然一个更新的事务把这个key删掉了）

   那就要走缓存击穿的解决方案了：加锁。会影响性能，所以视具体情况折中处理。





为保证最基本的**最终一致性**，就是设置过期时间。这样就算有脏数据，也会有个期限，在缓存过期之后就会从db拿最新数据。

> 这也是为什么缓存数据要设置过期时间的原因之一了。（没用了会占用内存，而且不然不知道啥时候该删除那个缓存）
>
> 如果每次访问cache更新缓存的过期时间，那就没有了最终一致性的保证。就必须在更新数据的时候保证将db中的最新数据更新到cache。



具体可以参考其他的缓存的思路，比如操作系统的缓存，cpu的缓存行，java的缓存和volitale。总会是性能和一致性的权衡。



### 如果非要保证强一致性

那就是db一旦修改，缓存中的就数据必须失效。所有读请求在`写事务完成之前`必须都是阻塞的，以读取到最新数据。

单机数据库可以 先删除缓存，并在数据库的对应的数据行加锁，要小心gapLock的特殊情况导致"锁表"。

数据库读写分离，就需要使用分布式锁了。性能下降肯定会严重。



如果使用读写锁，就可能导致写锁饥饿，解决方案就是公平锁，公平锁又会导致性能有下降。比如Java的ReentrantLock的 ReadWriteLock 的写锁饥饿和优化方案：StampLock（使用CLH锁和MCS锁）。



**分布式读写锁**实现比较复杂。可以使用中间件：Curator的 [InterProcessReadWriteLock](https://curator.apache.org/apidocs/org/apache/curator/framework/recipes/locks/InterProcessReadWriteLock.html)，Redisson的 [RReadWriteLock](https://static.javadoc.io/org.redisson/redisson/3.3.2/org/redisson/api/RReadWriteLock.html)。