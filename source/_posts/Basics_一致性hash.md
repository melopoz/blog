---
title: 一致性hash
tags: hash
categories: basics
date: 2021/01/01 20:46:25
updated: 2021/01/01 20:46:25
---



# 哈希算法

https://blog.csdn.net/cywosp/article/details/23397179

哈希算法`Hash`，也叫摘要算法`Digest`

> 输入一组任意长度的数据，计算得到一个固定长度的摘要数据。

```
java中重写equals()方法,为什么要重写hashCode()?
如果只是重写equals(), equals()=true，但hashCode()==false,这有悖于equals()和hashCode()方法的关系，以及hashCode的规则:

两个对象相等，hashcode一定相等
两个对象不等，hashcode不一定不等
hashcode相等，两个对象不一定相等
hashcode不等，两个对象一定不等

Object#hashCode是用对象的内存地址作为哈希算法的输入，所以重写hashCode()时要用对象的属性值作为入参
```

哈希碰撞，也就是会产生两个对象不等，hashCode可能相等的情况。这种情况不能避免，毕竟哈希算法是把一个无限的输入集合映射到有限的输出集合。

| 常用的哈希算法 | 输出bit长度 | 输出byte长度 |
| -------------- | ----------- | ------------ |
| MD5            | 128bits     | 16bytes      |
| RipeMD-160     | 160bits     | 20           |
| SHA-1          | 160bits     | 20           |
| SHA-256        | 256bits     | 32           |
| SHA-512        | 512bits     | 64           |

java中的hash算法：https://docs.oracle.com/en/java/javase/14/docs/specs/security/standard-names.html#messagedigest-algorithms



想要破解哈希算法，只能暴力穷举，想要提高穷举效率可以用**彩虹表**

> 彩虹表攻击：提前把一些常见的值生成hashCode存储起来，拿到要破解的hashCode之后先从表里查一遍，这就可能直接拿到该明文。

解决的办法也就是加盐了。计算hashCode时入参添加salt，并且可以进行n次哈希计算。





# 一致性哈希算法

一致性hash算法提出了在动态变化的Cache环境中，判定哈希算法好坏的四个定义：

> 1. 平衡性(Balance)：平衡性是指哈希的结果能够尽可能分布到所有的缓冲中去，这样可以使得所有的缓冲空间都得到利用。很多哈希算法都能够满足这一条件。
> 2. 单调性(Monotonicity)：单调性是指如果已经有一些内容通过哈希分派到了相应的缓冲中，又有新的缓冲加入到系统中。哈希的结果应能够保证原有已分配的内容可以被映射到原有的或者新的缓冲中去，而不会被映射到旧的缓冲集合中的其他(已失效)缓冲区。 
> 3. 分散性(Spread)：在分布式环境中，终端有可能看不到所有的缓冲，而是只能看到其中的一部分。当终端希望通过哈希过程将内容映射到缓冲上时，由于不同终端所见的缓冲范围有可能不同，从而导致哈希的结果不一致，最终的结果是相同的内容被不同的终端映射到不同的缓冲区中。这种情况显然是应该避免的，因为它导致相同内容被存储到不同缓冲中去，降低了系统存储的效率。分散性的定义就是上述情况发生的严重程度。好的哈希算法应能够尽量避免不一致的情况发生，也就是尽量降低分散性。 
> 4. 负载(Load)：负载问题实际上是从另一个角度看待分散性问题。既然不同的终端可能将相同的内容映射到不同的缓冲区中，那么对于一个特定的缓冲区而言，也可能被不同的用户映射为不同 的内容。与分散性一样，这种情况也是应当避免的，因此好的哈希算法应能够尽量降低缓冲的负荷。

在P2P环境、分布式环境中若使用常见的`hash(object)%N`算法来分配数据的存储位置，那么在有机器宕机或者删除后，很多原有的数据就无法找到了，这严重的违反了单调性原则。



#### 环形hash空间

用常用的hash算法，会得到一个固定长度的数，比如`CRC-16`产生的hash值是16bit，那么就有 2^16 = 65536 个值，

将这65536个值连成一个环形，就形成了一个hash环，有65536个hash槽。

> 比如redis的hash槽数量是16384，没用65536是因为节点之间ping-pong消息需要携带节点配置信息，节点越多消息体内容就越大。而节点应该不会超过1000，所以综合考虑使用了16384。

把所有机器的标识（id/唯一标识）进行hash得到环上的一点。

在计算数据要分配到哪个节点的时候，对这个数据进行hash，也得到环上的一点，然后只需要确定一个规则（比如把这个数据放在顺时针方向离它最近的一个hash槽）就能将这些数据分配到集群中的节点（机器）。

#### 节点宕机/删除节点

只需要把这个节点的数据转移到顺时针方向最近的一个节点上。

#### 节点恢复/添加节点

只需要把   新增节点->逆时针方向临近节点   之间所有的数据放到新增节点上。

#### 机器分布不均匀怎么办？ 这算法的分散性怎样得到高分

使用虚拟节点，让一个机器不止对应一个hash槽，比如一个机器对应的hash槽可能是`192.168.1.1#1` `192.168.1.1#2` `192.168.1.1#3`等三个hash槽

