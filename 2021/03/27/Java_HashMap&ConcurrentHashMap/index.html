

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=&#34;auto&#34;>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/blog/img/favicon.png">
  <link rel="icon" type="image/png" href="/blog/img/favicon.png">
  <meta name="viewport"
        content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="description" content="Although things are always not as you wish, but effort will be lucy!">
  <meta name="author" content="melopoz">
  <meta name="keywords" content="">
  <title>Java_HashMap不止是HashMap - 你不喜欢孤独 那就别停下来</title>

  <link  rel="stylesheet" href="https://cdn.staticfile.org/twitter-bootstrap/4.5.3/css/bootstrap.min.css" />


  <link  rel="stylesheet" href="https://cdn.staticfile.org/github-markdown-css/4.0.0/github-markdown.min.css" />
  <link  rel="stylesheet" href="/blog/lib/hint/hint.min.css" />

  
    
    
      
      <link  rel="stylesheet" href="https://cdn.staticfile.org/highlight.js/10.1.2/styles/github-gist.min.css" />
    
  

  
    <link  rel="stylesheet" href="https://cdn.staticfile.org/fancybox/3.5.7/jquery.fancybox.min.css" />
  



<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_ba1fz6golrf.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_kmeydafke9r.css">


<link  rel="stylesheet" href="/blog/css/main.css" />

<!-- 自定义样式保持在最底部 -->


  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    var CONFIG = {"hostname":"melopoz.github.io","root":"/blog/","version":"1.8.5","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false},"toc":{"enable":true,"headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"right","visible":"hover","icon":""},"copy_btn":true,"image_zoom":{"enable":true},"lazyload":{"enable":true,"onlypost":false},"web_analytics":{"enable":false,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null}}};
  </script>
  <script  src="/blog/js/utils.js" ></script>
  <script  src="/blog/js/color-schema.js" ></script>
<meta name="generator" content="Hexo 5.4.0"></head>


<body>
  <header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand"
       href="/blog/">&nbsp;<strong>Fluid</strong>&nbsp;</a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/blog/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/blog/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/blog/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/blog/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/blog/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" data-toggle="modal" data-target="#modalSearch">&nbsp;<i
                class="iconfont icon-search"></i>&nbsp;</a>
          </li>
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" href="javascript:">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="banner intro-2" id="background" parallax=true
         style="background: url('/blog/img/default.png') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="page-header text-center fade-in-up">
            <span class="h2" id="subtitle" title="Java_HashMap不止是HashMap">
              
            </span>

            
              <div class="mt-3">
  
  
    <span class="post-meta">
      <i class="iconfont icon-date-fill" aria-hidden="true"></i>
      <time datetime="2021-03-28 01:35" pubdate>
        2021年3月28日 凌晨
      </time>
    </span>
  
</div>

<div class="mt-1">
  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      4.4k 字
    </span>
  

  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      63
       分钟
    </span>
  

  
  
</div>

            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid">
  <div class="row">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-md">
      <div class="container nopadding-md" id="board-ctn">
        <div class="py-5" id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">Java_HashMap不止是HashMap</h1>
            
            <div class="markdown-body">
              <blockquote>
<p>算是面试吃瘪后，  <a target="_blank" rel="noopener" href="https://tech.meituan.com/2016/06/24/java-hashmap.html">https://tech.meituan.com/2016/06/24/java-hashmap.html</a>  的读后感吧 :)</p>
<p>一个字一个字写真是费劲啊… 这大概是最仔细的笔记了。</p>
<p>todo：去掉一些头脑发热的废话。</p>
</blockquote>
<h1 id="java-util-Map"><a href="#java-util-Map" class="headerlink" title="java.util.Map"></a>java.util.Map</h1><img src="https://raw.githubusercontent.com/melopoz/pics/master/img/java-util-map.png" srcset="/blog/img/loading.gif" style="zoom:50%;" />



<h2 id="常用实现"><a href="#常用实现" class="headerlink" title="常用实现"></a>常用实现</h2><ol>
<li><p>HashMap</p>
<p>根据hashCode存储数据，访问速度快，遍历顺序不确定，允许一个key为null，允许任意value为null，非线程安全，同一时刻多个线程同时对一个hashMap进行put，可能会导致数据不一致。</p>
<blockquote>
<p>可用Collections#synchronizedMap方法得到一个线程安全的map（直接synchronized入参的map对象）</p>
<p>或者用ConcurrentHashMap</p>
</blockquote>
</li>
<li><p>HashTable</p>
<p>遗留类，不建议用，一般也不用这玩意了。常用功能和HashMap类似，不过HashTable是<code>extends Dictionary implements Map</code>，线程安全，但并发性不如ConcurrentHashMap，他的方法是synchronized的。</p>
</li>
<li><p>LinkedHashMap</p>
<p>继承自HashMap，记录了key的插入顺序</p>
<blockquote>
<p>accessOrder参数：默认false，是根据第一次插入该key的顺序排序；true：每次访问都更新排序，也就是get(k)、再put(k,v)都会将k放到最后。</p>
</blockquote>
</li>
<li><p>TreeMap</p>
<p>实现NavigableMap接口(navigable:可导航的)，NavigableMap继承SortedMap接口。Entry根据key排序，默认按照key升序排序，也可以指定用于排序的比较器。</p>
<blockquote>
<p>使用TreeMap时，key必须实现Comparable接口或者在TreeMap的构造函数中传入自定义的Comparator，否则运行时会throw ClassCastException。</p>
</blockquote>
</li>
</ol>
<h2 id="HashMap内部实现"><a href="#HashMap内部实现" class="headerlink" title="HashMap内部实现"></a>HashMap内部实现</h2><h3 id="数据结构-amp-属性"><a href="#数据结构-amp-属性" class="headerlink" title="数据结构 &amp; 属性"></a>数据结构 &amp; 属性</h3><p>数组 + 链表 / 红黑树(1.8增加红黑树)</p>
<img src="https://raw.githubusercontent.com/melopoz/pics/master/img/HashMap%E7%BB%93%E6%9E%84.png" srcset="/blog/img/loading.gif" style="zoom:50%;" />

<h4 id="Node-lt-K-V-gt-table；"><a href="#Node-lt-K-V-gt-table；" class="headerlink" title="Node&lt;K, V&gt;[] table；"></a><code>Node&lt;K, V&gt;[] table；</code></h4><p>哈希桶数组，每个元素都是一个键值对：<code>Node&lt;K,V&gt; implements Map.Entry</code>。</p>
<blockquote>
<p>hash可能会冲突，可以采用开放地址法、链地址法。HashMap采用链地址法。</p>
<blockquote>
<p>开放地址法：每当目标位置不是空的，就像下寻找，直到找到空位置。</p>
</blockquote>
<p>这种结构必然要权衡空间成本和时间成本，需要用好的hash算法和扩容机制来让table占据空间小，又不容易发生hash碰撞。</p>
<p>table默认长度<code>length</code>为<code>16</code>，负载因子<code>loadFactor</code>为<code>0.75</code>。</p>
<p>阈值<code>threshold</code> = <code>length * loadFactor</code>，table中的元素个数超过threshold之后就要resize()。</p>
<blockquote>
<p>时间效率要求极高就减小threshold，内存紧张就调大threshold。</p>
</blockquote>
</blockquote>
<h4 id="table-length"><a href="#table-length" class="headerlink" title="table.length"></a>table.length</h4><p>必须为2的n次方，扩容(resize)就 *2</p>
<blockquote>
<p>因为他用key的hash值对（length-1）取模（&amp;）。<strong>为了减少hash冲突</strong>。可以看resize()的代码和下文<strong>确定node在table中的索引位置</strong>。</p>
<pre><code class="hljs java"><span class="hljs-keyword">final</span> Node&lt;K,V&gt;[] resize() &#123;
        Node&lt;K,V&gt;[] oldTab = table;<span class="hljs-comment">// 旧table</span>
        <span class="hljs-keyword">int</span> oldCap = (oldTab == <span class="hljs-keyword">null</span>) ? <span class="hljs-number">0</span> : oldTab.length;<span class="hljs-comment">// 旧容量</span>
        <span class="hljs-keyword">int</span> oldThr = threshold;<span class="hljs-comment">// 旧阈值</span>
        <span class="hljs-keyword">int</span> newCap, newThr = <span class="hljs-number">0</span>;<span class="hljs-comment">// 新容量 新阈值</span>
        <span class="hljs-keyword">if</span> (oldCap &gt; <span class="hljs-number">0</span>) &#123;
        	...
            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ((newCap = oldCap &lt;&lt; <span class="hljs-number">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp;
                     oldCap &gt;= DEFAULT_INITIAL_CAPACITY)
                <span class="hljs-comment">// 新容量 = 旧容量 * 2</span>
                newThr = oldThr &lt;&lt; <span class="hljs-number">1</span>; <span class="hljs-comment">// double threshold</span>
        &#125;
        ...
        <span class="hljs-keyword">if</span> (oldTab != <span class="hljs-keyword">null</span>) &#123;
            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; oldCap; ++j) &#123;<span class="hljs-comment">// 把entry放到新数组对应的位置</span>
                newTab[e.hash &amp; (newCap - <span class="hljs-number">1</span>)] = e;<span class="hljs-comment">// 用entry.key的hash对 新容量-1 取模，这样就能用上所有的bit</span>
                <span class="hljs-comment">// 举个例子 16-1=15，二进制为`.. 0000 1111`，这样有效位是后四位全部，而且还在容量范围之内。</span>
        ...
&#125;</code></pre>

<p>对比HashTable来看，hashTable扩容是<code>*2-1</code>，初始容量是个素数<code>11</code>，但是扩容后就不一定了。</p>
<p>一般来说容量是素数更能减少hash冲突（如果直接对length取模）（二进制的情况下1多0少），hashMap容量是2，但是他取模的时候巧妙的用的<code>length-1</code>，这样同样也是为了二进制下1多0少，让hash值&amp;运算的时候能有更多有效bit。</p>
<blockquote>
<p>ps：Ali，DiDi面试好像都问到这个了，当时由于脑子空白，也忘了回答的啥了 T.T。</p>
<blockquote>
<p>啊！我想起来了，dalao问有什么比取余效率更高的。。其实就是让hash &amp; (length-1)，位运算-&amp;运算肯定比数学运算-%取余 效率要高啊。</p>
<p>我以后应该不会说<code>取模/模以length</code>了，我以为我在说 &amp; 运算，其实对方可能以为我说的是数学的取余。T.T</p>
<p>突然想起高中数学老师如果改行敲代码应该也会是个大佬…</p>
</blockquote>
</blockquote>
</blockquote>
<h4 id="modCount"><a href="#modCount" class="headerlink" title="modCount"></a>modCount</h4><p>记录hashMap内部结构发生变化的次数，主要用于迭代的快速失败（fail-fast）。</p>
<blockquote>
<p>put新Entry算，put已存在的key(覆盖)不算。</p>
</blockquote>
<blockquote>
<p>可以看<code>java.util.HashMap.HashIterator#nextNode</code>的代码，很简单。</p>
<pre><code class="hljs java"><span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HashIterator</span> </span>&#123;
    Node&lt;K,V&gt; next;        <span class="hljs-comment">// next entry to return</span>
    Node&lt;K,V&gt; current;     <span class="hljs-comment">// current entry</span>
    <span class="hljs-keyword">int</span> expectedModCount;  <span class="hljs-comment">// for fast-fail</span>
    <span class="hljs-keyword">int</span> index;             <span class="hljs-comment">// current slot</span>

    HashIterator() &#123;
        expectedModCount = modCount;<span class="hljs-comment">// 开始迭代的时候 map实例的修改次数(其实可以理解为版本号嘛)</span>
        Node&lt;K,V&gt;[] t = table;
        current = next = <span class="hljs-keyword">null</span>;
        index = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">if</span> (t != <span class="hljs-keyword">null</span> &amp;&amp; size &gt; <span class="hljs-number">0</span>) &#123; <span class="hljs-comment">// advance to first entry</span>
            <span class="hljs-keyword">do</span> &#123;&#125; <span class="hljs-keyword">while</span> (index &lt; t.length &amp;&amp; (next = t[index++]) == <span class="hljs-keyword">null</span>);
        &#125;
    &#125;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">hasNext</span><span class="hljs-params">()</span> </span>&#123;
        <span class="hljs-keyword">return</span> next != <span class="hljs-keyword">null</span>;
    &#125;

    <span class="hljs-function"><span class="hljs-keyword">final</span> Node&lt;K,V&gt; <span class="hljs-title">nextNode</span><span class="hljs-params">()</span> </span>&#123;
        Node&lt;K,V&gt;[] t;
        Node&lt;K,V&gt; e = next;
        <span class="hljs-keyword">if</span> (modCount != expectedModCount)<span class="hljs-comment">// 迭代的时候如果map的结构被改动过</span>
            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> ConcurrentModificationException();<span class="hljs-comment">// 熟悉的exception</span>
        <span class="hljs-keyword">if</span> (e == <span class="hljs-keyword">null</span>)
            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> NoSuchElementException();
        <span class="hljs-keyword">if</span> ((next = (current = e).next) == <span class="hljs-keyword">null</span> &amp;&amp; (t = table) != <span class="hljs-keyword">null</span>) &#123;
            <span class="hljs-keyword">do</span> &#123;&#125; <span class="hljs-keyword">while</span> (index &lt; t.length &amp;&amp; (next = t[index++]) == <span class="hljs-keyword">null</span>);
        &#125;
        <span class="hljs-keyword">return</span> e;
    &#125;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">remove</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-comment">// 所以推荐用iter.remove()</span>
        Node&lt;K,V&gt; p = current;
        <span class="hljs-keyword">if</span> (p == <span class="hljs-keyword">null</span>)
            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalStateException();
        <span class="hljs-keyword">if</span> (modCount != expectedModCount)
            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> ConcurrentModificationException();
        current = <span class="hljs-keyword">null</span>;
        K key = p.key;
        removeNode(hash(key), key, <span class="hljs-keyword">null</span>, <span class="hljs-keyword">false</span>, <span class="hljs-keyword">false</span>);
        expectedModCount = modCount;<span class="hljs-comment">// 会更新期望版本号</span>
    &#125;
&#125;</code></pre>

<p><code>java.util.ListIterator</code>的代码也是如此，调用迭代器的iterator的remove()方法会更新<code>modCount</code>和<code>expectedModCount</code>，不会<code>throw new ConcurrentModificationException()</code>。</p>
</blockquote>
<h3 id="功能实现"><a href="#功能实现" class="headerlink" title="功能实现"></a>功能实现</h3><h4 id="确定node在table中的索引位置"><a href="#确定node在table中的索引位置" class="headerlink" title="确定node在table中的索引位置"></a>确定node在table中的索引位置</h4><p>确定元素在table中的位置总的来说，就是<code>hash值 &amp; (length-1)</code>，得到一个0~length的位置。</p>
<pre><code class="hljs java"><span class="hljs-comment">// 求key的hash，让高位也参与了运算</span>
<span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> <span class="hljs-title">hash</span><span class="hljs-params">(Object key)</span> </span>&#123;
    <span class="hljs-keyword">int</span> h;
    <span class="hljs-comment">// hash值 异或 hash值的高位(前16位)</span>
    <span class="hljs-keyword">return</span> (key == <span class="hljs-keyword">null</span>) ? <span class="hljs-number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="hljs-number">16</span>);<span class="hljs-comment">// 逻辑右移，移动完第一位符号位肯定是0，是个正整数了</span>
&#125;
<span class="hljs-comment">// Object#hashCode</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">native</span> <span class="hljs-keyword">int</span> <span class="hljs-title">hashCode</span><span class="hljs-params">()</span></span>;<span class="hljs-comment">// int 32位</span>
<span class="hljs-comment">// 比如resize()方法重新计算位置的时候,前边有介绍了</span>
<span class="hljs-comment">// newTab[e.hash &amp; (newCap - 1)] = e;</span></code></pre>



<h4 id="put-K-V-方法"><a href="#put-K-V-方法" class="headerlink" title="put(K, V)方法"></a>put(K, V)方法</h4><p>流程就是这样，就是判断是否扩容，改index一共有多少个Node，多了就红黑树，少了就链表。所以就记一下触发这些操作的条件吧</p>
<img src="https://raw.githubusercontent.com/melopoz/pics/master/img/HashMap" srcset="/blog/img/loading.gif" style="zoom:40%;" />

<pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> V <span class="hljs-title">put</span><span class="hljs-params">(K key, V value)</span> </span>&#123;
    <span class="hljs-keyword">return</span> putVal(hash(key), key, value, <span class="hljs-keyword">false</span>, <span class="hljs-keyword">true</span>);
&#125;
<span class="hljs-function"><span class="hljs-keyword">final</span> V <span class="hljs-title">putVal</span><span class="hljs-params">(<span class="hljs-keyword">int</span> hash, K key, V value, <span class="hljs-keyword">boolean</span> onlyIfAbsent, <span class="hljs-keyword">boolean</span> evict)</span> </span>&#123;
    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="hljs-keyword">int</span> n, i;
    <span class="hljs-keyword">if</span> ((tab = table) == <span class="hljs-keyword">null</span> || (n = tab.length) == <span class="hljs-number">0</span>) <span class="hljs-comment">// table是空的 扩容(初始化扩容)</span>
        n = (tab = resize()).length;
    <span class="hljs-keyword">if</span> ((p = tab[i = (n - <span class="hljs-number">1</span>) &amp; hash]) == <span class="hljs-keyword">null</span>)<span class="hljs-comment">// key不存在 直接放到对应索引位</span>
        tab[i] = newNode(hash, key, value, <span class="hljs-keyword">null</span>);
    <span class="hljs-keyword">else</span> &#123;
        Node&lt;K,V&gt; e; K k;<span class="hljs-comment">// p: table[i]处的head节点</span>
        <span class="hljs-keyword">if</span> (p.hash == hash &amp;&amp;
              ((k = p.key) == key || (key != <span class="hljs-keyword">null</span> &amp;&amp; key.equals(k))))<span class="hljs-comment">// 要插入的节点对应table[i]处链表的head 直接走后边的覆盖逻辑</span>
            e = p;
        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (p <span class="hljs-keyword">instanceof</span> TreeNode)<span class="hljs-comment">// 是树节点</span>
            e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="hljs-keyword">this</span>, tab, hash, key, value);
        <span class="hljs-keyword">else</span> &#123;<span class="hljs-comment">// 否则就遍历链表，找到key相同的节点或者加到tail后边</span>
            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> binCount = <span class="hljs-number">0</span>; ; ++binCount) &#123;
                <span class="hljs-keyword">if</span> ((e = p.next) == <span class="hljs-keyword">null</span>) &#123;<span class="hljs-comment">// table[i]处就一个节点</span>
                    p.next = newNode(hash, key, value, <span class="hljs-keyword">null</span>);
                    <span class="hljs-keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="hljs-number">1</span>) <span class="hljs-comment">// -1 for 1st  </span>
                        treeifyBin(tab, hash); <span class="hljs-comment">// TREEIFY_THRESHOLD=8，所以如果当前节点是第9个就会转换成红黑树</span>
                    <span class="hljs-keyword">break</span>;
                &#125;
                <span class="hljs-keyword">if</span> (e.hash == hash &amp;&amp;
                    ((k = e.key) == key || (key != <span class="hljs-keyword">null</span> &amp;&amp; key.equals(k)))) <span class="hljs-comment">// 如果key已经存在 就覆盖</span>
                    <span class="hljs-keyword">break</span>;
                p = e;
            &#125;
        &#125;
        
        <span class="hljs-keyword">if</span> (e != <span class="hljs-keyword">null</span>) &#123; <span class="hljs-comment">// existing mapping for key</span>
            V oldValue = e.value;
            <span class="hljs-keyword">if</span> (!onlyIfAbsent || oldValue == <span class="hljs-keyword">null</span>)
                e.value = value;
            afterNodeAccess(e);<span class="hljs-comment">// LinkedHashMap重写了这个方法进行排序，如果设置了accessOrder=true，则访问节点之后节点要放到最后</span>
            <span class="hljs-keyword">return</span> oldValue;
        &#125;
    &#125;
    ++modCount;
    <span class="hljs-keyword">if</span> (++size &gt; threshold) <span class="hljs-comment">// 超过阈值就扩容</span>
        resize();
    afterNodeInsertion(evict); <span class="hljs-comment">// 插入节点之后 同上边 afterNodeAccess..</span>
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;
&#125;</code></pre>



<h4 id="扩容-resize"><a href="#扩容-resize" class="headerlink" title="扩容 resize()"></a>扩容 resize()</h4><p>table是数组，不能扩容，所以肯定开辟新空间，再复制过去。</p>
<p>由于扩容是旧容量*2：<code>newCap = oldCap &lt;&lt; 1</code>，key的hash值是固定的，so，举个例子：(就只看后八位了)</p>
<blockquote>
<p>假设  hash(key1) = <code>0000 0101</code>，hash(key2) = <code>0001 0101</code></p>
<p>oldCap= 16（15的二进制：<code>0000 1111</code>）</p>
<p>这两个key通过<code>hash(key)&amp;(length-1)</code>运算得到的位置都是<strong>5</strong> <code>0101</code>。</p>
<p>key1对应的位置：<code>0000 0101</code> &amp; <code>0000 1111</code> = 5（ <code>0000 0101</code>）</p>
<p>key2对应的位置：<code>0001 0101</code> &amp; <code>0000 1111</code> = <strong>5</strong>（ <code>0000 0101</code>）</p>
</blockquote>
<p>扩容之后：</p>
<blockquote>
<p>newCap：32（31的二进制：<code>0001 1111</code>）</p>
<p>key1对应的位置：<code>0000 0101</code> &amp; <code>0001 1111</code> = 5（ <code>0000 0101</code>）</p>
<p>key2对应的位置：<code>0001 0101</code> &amp; <code>0001 1111</code> = <strong>21</strong>（ <code>0001 0101</code>）</p>
</blockquote>
<img src="https://raw.githubusercontent.com/melopoz/pics/master/img/resize-key%E7%9A%84%E6%96%B0%E7%B4%A2%E5%BC%95%E4%BD%8D%E7%BD%AE.png" srcset="/blog/img/loading.gif" style="zoom: 50%;" />

<p>这么看来key在新table中的位置只有两种可能：<code>oldIndex</code>或者<code>oldIndex + oldCap</code>，决定因素就是<code>hash(key)</code>在<code>mask的高位新增位(上图红色的1)</code> 对应的bit是1还是0，这个只有一位高电平的mask(<code>0001 0000</code>)，不就是oldCap嘛。<strong>哦，这就是1.8的其中一个优化</strong>。</p>
<blockquote>
<p>Ctrl+F 搜索<code>&quot;oldCap做mask 重hash优化&quot;</code>找到对应的代码  :)</p>
</blockquote>
<p>resize()源码，淦</p>
<pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> DEFAULT_INITIAL_CAPACITY = <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">4</span>; <span class="hljs-comment">// aka 16 // 初始化容量</span>
<span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> MAXIMUM_CAPACITY = <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">30</span>;<span class="hljs-comment">// 最大容量</span>
<span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">float</span> DEFAULT_LOAD_FACTOR = <span class="hljs-number">0.75f</span>;<span class="hljs-comment">// 默认负载因子</span>
<span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> TREEIFY_THRESHOLD = <span class="hljs-number">8</span>;<span class="hljs-comment">// 树化的阈值，链表超过8个，就转为红黑树（条件一）</span>
<span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> UNTREEIFY_THRESHOLD = <span class="hljs-number">6</span>;<span class="hljs-comment">// 红黑树的节点个数小于6就转为链表</span>
<span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> MIN_TREEIFY_CAPACITY = <span class="hljs-number">64</span>;<span class="hljs-comment">// table的容量低于64不会树化（条件二）</span>

<span class="hljs-keyword">final</span> Node&lt;K,V&gt;[] resize() &#123;
    Node&lt;K,V&gt;[] oldTab = table;
    <span class="hljs-keyword">int</span> oldCap = (oldTab == <span class="hljs-keyword">null</span>) ? <span class="hljs-number">0</span> : oldTab.length;
    <span class="hljs-keyword">int</span> oldThr = threshold;
    <span class="hljs-keyword">int</span> newCap, newThr = <span class="hljs-number">0</span>;
    <span class="hljs-comment">// 上来先 base case ..</span>
    <span class="hljs-keyword">if</span> (oldCap &gt; <span class="hljs-number">0</span>) &#123;
        <span class="hljs-keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;<span class="hljs-comment">// MAXIMUM_CAPACITY = 1 &lt;&lt; 30;</span>
            threshold = Integer.MAX_VALUE;<span class="hljs-comment">// 容量超过最大值，把阈值也搞大，这样以后就不用resize()了</span>
            <span class="hljs-keyword">return</span> oldTab;
        &#125;
        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ((newCap = oldCap &lt;&lt; <span class="hljs-number">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp;<span class="hljs-comment">// 容量 *2</span>
                 oldCap &gt;= DEFAULT_INITIAL_CAPACITY)<span class="hljs-comment">// DEFAULT_INITIAL_CAPACITY = 1 &lt;&lt; 4; // 16</span>
            newThr = oldThr &lt;&lt; <span class="hljs-number">1</span>; <span class="hljs-comment">// double threshold // 阈值也 *2</span>
    &#125;
    <span class="hljs-keyword">else</span><span class="hljs-comment">/*oldCap==0*/</span> <span class="hljs-keyword">if</span> (oldThr &gt; <span class="hljs-number">0</span>) <span class="hljs-comment">// initial capacity was placed in threshold</span>
        newCap = oldThr;<span class="hljs-comment">// 初始容量设置为阈值</span>
    <span class="hljs-keyword">else</span><span class="hljs-comment">/*oldCap==0 &amp;&amp; oldThr == 0*/</span> &#123; <span class="hljs-comment">// zero initial threshold signifies using defaults</span>
        <span class="hljs-comment">// 没有设置初始阈值，就使用默认值</span>
        newCap = DEFAULT_INITIAL_CAPACITY;
        newThr = (<span class="hljs-keyword">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);
    &#125;
    <span class="hljs-keyword">if</span> (newThr == <span class="hljs-number">0</span>) &#123; <span class="hljs-comment">// 如果newThr为0，那直接设置容量为Integer.MAX</span>
        <span class="hljs-keyword">float</span> ft = (<span class="hljs-keyword">float</span>)newCap * loadFactor;
        newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class="hljs-keyword">float</span>)MAXIMUM_CAPACITY ?
                  (<span class="hljs-keyword">int</span>)ft : Integer.MAX_VALUE);
    &#125;
    <span class="hljs-comment">// 开始</span>
    threshold = newThr;
    <span class="hljs-meta">@SuppressWarnings(&#123;&quot;rawtypes&quot;,&quot;unchecked&quot;&#125;)</span>
    Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class="hljs-keyword">new</span> Node[newCap];<span class="hljs-comment">// 开辟newTab空间</span>
    table = newTab;
    <span class="hljs-keyword">if</span> (oldTab != <span class="hljs-keyword">null</span>) &#123;
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; oldCap; ++j) &#123;<span class="hljs-comment">// 遍历oldTable</span>
            Node&lt;K,V&gt; e;
            <span class="hljs-keyword">if</span> ((e = oldTab[j]) != <span class="hljs-keyword">null</span>) &#123;
                oldTab[j] = <span class="hljs-keyword">null</span>;<span class="hljs-comment">// 去掉以前的引用 help GC</span>
                <span class="hljs-keyword">if</span> (e.next == <span class="hljs-keyword">null</span>)<span class="hljs-comment">// 说明这个位置就一个node</span>
                    newTab[e.hash &amp; (newCap - <span class="hljs-number">1</span>)] = e;<span class="hljs-comment">// 放到新table对应的位置</span>
                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (e <span class="hljs-keyword">instanceof</span> TreeNode)<span class="hljs-comment">// 是红黑树节点</span>
                    ((TreeNode&lt;K,V&gt;)e).split(<span class="hljs-keyword">this</span>, newTab, j, oldCap);<span class="hljs-comment">// todo todo todo </span>
                <span class="hljs-keyword">else</span> <span class="hljs-comment">/*这个位置是链表*/</span>&#123; <span class="hljs-comment">// preserve order  保存顺序</span>
                    Node&lt;K,V&gt; loHead = <span class="hljs-keyword">null</span>, loTail = <span class="hljs-keyword">null</span>;<span class="hljs-comment">// 假设容量是从16扩容到32，loHead就是table[15]这个head</span>
                    Node&lt;K,V&gt; hiHead = <span class="hljs-keyword">null</span>, hiTail = <span class="hljs-keyword">null</span>;<span class="hljs-comment">// 那么hiHead就是table[31]这个head</span>
                    Node&lt;K,V&gt; next;
                    <span class="hljs-keyword">do</span> &#123;<span class="hljs-comment">// 先去看下边while条件，就是遍历这个链表</span>
                        next = e.next;<span class="hljs-comment">// 先留一份当前node的next的指针,while的时候用</span>
                        <span class="hljs-comment">// 这就是上边说的那个   &quot;oldCap做mask 重hash优化&quot;</span>
                        <span class="hljs-comment">// 因为只可能是这两个位置，所以操作这两个index的head和tail指针就ok了（上边声明的四个变量）</span>
                        <span class="hljs-keyword">if</span> ((e.hash &amp; oldCap) == <span class="hljs-number">0</span>) &#123;<span class="hljs-comment">// 说明该元素在新table中的位置还是oldIndex</span>
                            <span class="hljs-keyword">if</span> (loTail == <span class="hljs-keyword">null</span>)<span class="hljs-comment">// 只有第一次来newTable[j]这个位置肯定是null</span>
                                loHead = e;<span class="hljs-comment">// loHead指针直接指向这个新node</span>
                            <span class="hljs-keyword">else</span>
                                loTail.next = e;<span class="hljs-comment">// 第二次之后插入到table[j]对应链表的tail之后</span>
                            loTail = e;<span class="hljs-comment">// 更新tail节点指向新的node嘛</span>
                        &#125;
                        <span class="hljs-keyword">else</span> &#123;<span class="hljs-comment">// 说明该元素在新table中的位置是 oldIndex + oldCap</span>
                            <span class="hljs-keyword">if</span> (hiTail == <span class="hljs-keyword">null</span>)
                                hiHead = e;
                            <span class="hljs-keyword">else</span>
                                hiTail.next = e;
                            hiTail = e;<span class="hljs-comment">// 这里和上边就一个意思了</span>
                        &#125;
                    &#125; <span class="hljs-keyword">while</span> ((e = next) != <span class="hljs-keyword">null</span>);
                    <span class="hljs-keyword">if</span> (loTail != <span class="hljs-keyword">null</span>) &#123;<span class="hljs-comment">// 说明newTable[j]这个位置有节点</span>
                        loTail.next = <span class="hljs-keyword">null</span>;
                        newTab[j] = loHead;<span class="hljs-comment">// loHead 和 hiHead 都已经指向该指向的节点了，loHead放到newTable的低索引位</span>
                    &#125;
                    <span class="hljs-keyword">if</span> (hiTail != <span class="hljs-keyword">null</span>) &#123;
                        hiTail.next = <span class="hljs-keyword">null</span>;
                        newTab[j + oldCap] = hiHead;<span class="hljs-comment">// hiHead放到newTable的高索引位</span>
                    &#125;
                &#125;
            &#125;
        &#125;
    &#125;
    <span class="hljs-keyword">return</span> newTab;
&#125;</code></pre>

<p>再来看看1.7的源码</p>
<pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">transfer</span> <span class="hljs-params">(Entry[] newTable)</span></span>&#123;
    Entry[] src = table;<span class="hljs-comment">//old table</span>
    <span class="hljs-keyword">int</span> newCapacity = newTable.length;
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; src.length; j++) &#123;
        Entry&lt;K, V&gt; e = src[j];<span class="hljs-comment">// e就是旧table lo索引位的 head节点</span>
        <span class="hljs-keyword">if</span> (e != <span class="hljs-keyword">null</span>) &#123;
            src[j] = <span class="hljs-keyword">null</span>;<span class="hljs-comment">//释放旧Entry数组的对象引用 help GC</span>
            <span class="hljs-keyword">do</span> &#123;
                Entry&lt;K, V&gt; next = e.next;<span class="hljs-comment">// 持有一份当前node的next指针</span>
                <span class="hljs-keyword">int</span> i = indexFor(e.hash, newCapacity); <span class="hljs-comment">// 重新计算每个元素在数组中的位置 还是用的 e.hash &amp; (newCapacity-1)</span>
                e.next = newTable[i]; <span class="hljs-comment">// 将newTable[i]处的链表接到当前node后边。（！死循环就是这里的问题）</span>
                newTable[i] = e;      <span class="hljs-comment">// 将当前node放到newTable[i]处    头插法！</span>
                e = next;
            &#125; <span class="hljs-keyword">while</span> (e != <span class="hljs-keyword">null</span>);
        &#125;
    &#125;
&#125;
<span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">indexFor</span><span class="hljs-params">(<span class="hljs-keyword">int</span> h, <span class="hljs-keyword">int</span> length)</span> </span>&#123;
     <span class="hljs-keyword">return</span> h &amp; (length-<span class="hljs-number">1</span>);
&#125;</code></pre>

<p>1.8用的是尾插法，1.7的代码中用的是头插法，元素位置会倒置，而且可能死循环</p>
<h4 id="树化操作-treeifyBin"><a href="#树化操作-treeifyBin" class="headerlink" title="树化操作 treeifyBin()"></a>树化操作 treeifyBin()</h4><p>put()方法中，如果一个hash槽的节点数&gt;8，就会调用treeifyBin(..)方法进行树化。</p>
<pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">treeifyBin</span><span class="hljs-params">(Node&lt;K,V&gt;[] tab, <span class="hljs-keyword">int</span> hash)</span> </span>&#123;
    <span class="hljs-keyword">int</span> n, index; Node&lt;K,V&gt; e;
    <span class="hljs-keyword">if</span> (tab == <span class="hljs-keyword">null</span> || (n = tab.length) &lt; MIN_TREEIFY_CAPACITY) <span class="hljs-comment">// 如果元素个数 &lt; 64 会扩容而不是转换成红黑树。</span>
        resize();
    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ((e = tab[index = (n - <span class="hljs-number">1</span>) &amp; hash]) != <span class="hljs-keyword">null</span>) &#123;
        TreeNode&lt;K,V&gt; hd = <span class="hljs-keyword">null</span>, tl = <span class="hljs-keyword">null</span>;
        <span class="hljs-keyword">do</span> &#123;
            TreeNode&lt;K,V&gt; p = replacementTreeNode(e, <span class="hljs-keyword">null</span>);
            <span class="hljs-keyword">if</span> (tl == <span class="hljs-keyword">null</span>)
                hd = p;
            <span class="hljs-keyword">else</span> &#123;
                p.prev = tl;
                tl.next = p;
            &#125;
            tl = p;
        &#125; <span class="hljs-keyword">while</span> ((e = e.next) != <span class="hljs-keyword">null</span>);
        <span class="hljs-keyword">if</span> ((tab[index] = hd) != <span class="hljs-keyword">null</span>)
            hd.treeify(tab);
    &#125;
&#125;</code></pre>



<h4 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h4><h3 id="常见问题："><a href="#常见问题：" class="headerlink" title="常见问题："></a>常见问题：</h3><h6 id="扩容的时间复杂度是多少"><a href="#扩容的时间复杂度是多少" class="headerlink" title="扩容的时间复杂度是多少"></a>扩容的时间复杂度是多少</h6><blockquote>
<p>O(logn) ~ O(n)</p>
<p>肯定要要遍历所有node，如果每个节点都是红黑树，那就是cap*log(n)，去掉常量就是O(logn)，如果都是链表，相当于遍历cap次。</p>
<p>(注意不会因为for嵌套do-while就是O(²))。</p>
</blockquote>
<h6 id="一些细节-特点"><a href="#一些细节-特点" class="headerlink" title="一些细节 特点"></a>一些细节 特点</h6><blockquote>
<p>扩容非常耗时，尽量初始化的时候预估容量。</p>
<p>负载因子loadFactor是可以指定的，不是特殊情况不要改。</p>
</blockquote>
<h6 id="1-8做了哪些优化"><a href="#1-8做了哪些优化" class="headerlink" title="1.8做了哪些优化"></a>1.8做了哪些优化</h6><blockquote>
<ol>
<li>加入红黑树；</li>
<li>头插法换成尾插法，和红黑树结构均能防止死循环；</li>
<li>求key对应的索引位置时用 oldCap 做mask 直接判断 node 对应的索引是 oldIndex 还是 oldIndex + oldCap。</li>
</ol>
</blockquote>
<h6 id="为啥用红黑树？"><a href="#为啥用红黑树？" class="headerlink" title="为啥用红黑树？"></a>为啥用红黑树？</h6><blockquote>
<p>如果hash函数结构够均匀，性能大概是提升15%。</p>
</blockquote>
<blockquote>
<p>如果hash函数很垃圾，比如极端情况所有hash(key)都相同。那每次都要遍历table[j]处对应的链表，1.7在这种情况下时间复杂度直接变成O(n)，1.8引入红黑树，在这种情况下节点越多查询节点可能越小，时间复杂度下降为O(logn)。</p>
</blockquote>
<h6 id="怎么解决1-7那个死循环的？"><a href="#怎么解决1-7那个死循环的？" class="headerlink" title="怎么解决1.7那个死循环的？"></a>怎么解决1.7那个死循环的？</h6><blockquote>
<p>1.7是把node放到newTable[j]处的head（头插法），1.8是放到newTable[j]的tail.next（尾插法）。即使线程不安全，出问题也就是可能node会有重复</p>
</blockquote>
<h1 id="ConcurrentHashMap"><a href="#ConcurrentHashMap" class="headerlink" title="ConcurrentHashMap"></a>ConcurrentHashMap</h1><blockquote>
<p> key和value不能为null，key不能，value不能因为多线程使用，有歧义</p>
</blockquote>
<p>jdk1.7 使用segment分段锁</p>
<h3 id="jdk1-8"><a href="#jdk1-8" class="headerlink" title="jdk1.8"></a>jdk1.8</h3><p>get()</p>
<blockquote>
<p>使用volatile修饰变量，直接get，不会获取到旧值。</p>
<pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> V <span class="hljs-title">get</span><span class="hljs-params">(Object key)</span> </span>&#123;
     Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; e, p; <span class="hljs-keyword">int</span> n, eh; K ek;
     <span class="hljs-keyword">int</span> h = spread(key.hashCode());<span class="hljs-comment">//散列 得到key在数组中的位置</span>
     <span class="hljs-keyword">if</span> ((tab = table) != <span class="hljs-keyword">null</span> &amp;&amp; (n = tab.length) &gt; <span class="hljs-number">0</span> &amp;&amp;
         (e = tabAt(tab, (n - <span class="hljs-number">1</span>) &amp; h)) != <span class="hljs-keyword">null</span>) &#123;
         <span class="hljs-keyword">if</span> ((eh = e.hash) == h) &#123;
             <span class="hljs-keyword">if</span> ((ek = e.key) == key || (ek != <span class="hljs-keyword">null</span> &amp;&amp; key.equals(ek)))
                 <span class="hljs-keyword">return</span> e.val;
         &#125;
         <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (eh &lt; <span class="hljs-number">0</span>)
             <span class="hljs-keyword">return</span> (p = e.find(h, key)) != <span class="hljs-keyword">null</span> ? p.val : <span class="hljs-keyword">null</span>;
         <span class="hljs-keyword">while</span> ((e = e.next) != <span class="hljs-keyword">null</span>) &#123;
             <span class="hljs-keyword">if</span> (e.hash == h &amp;&amp;
                 ((ek = e.key) == key || (ek != <span class="hljs-keyword">null</span> &amp;&amp; key.equals(ek))))
                 <span class="hljs-keyword">return</span> e.val;
         &#125;
     &#125;
     <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;
 &#125;
<span class="hljs-meta">@SuppressWarnings(&quot;unchecked&quot;)</span>
<span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> &lt;K,V&gt; <span class="hljs-function">Node&lt;K,V&gt; <span class="hljs-title">tabAt</span><span class="hljs-params">(Node&lt;K,V&gt;[] tab, <span class="hljs-keyword">int</span> i)</span> </span>&#123;
 <span class="hljs-keyword">return</span> (Node&lt;K,V&gt;)U.getObjectVolatile(tab, ((<span class="hljs-keyword">long</span>)i &lt;&lt; ASHIFT) + ABASE);
&#125;</code></pre>


</blockquote>
<p>put()</p>
<blockquote>
<p>使用cas和synchronized：</p>
<pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> V <span class="hljs-title">put</span><span class="hljs-params">(K key, V value)</span> </span>&#123;
 <span class="hljs-keyword">return</span> putVal(key, value, <span class="hljs-keyword">false</span>);
&#125;

<span class="hljs-comment">/** Implementation for put and putIfAbsent */</span>
<span class="hljs-function"><span class="hljs-keyword">final</span> V <span class="hljs-title">putVal</span><span class="hljs-params">(K key, V value, <span class="hljs-keyword">boolean</span> onlyIfAbsent)</span> </span>&#123;
 <span class="hljs-keyword">if</span> (key == <span class="hljs-keyword">null</span> || value == <span class="hljs-keyword">null</span>) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> NullPointerException();
 <span class="hljs-keyword">int</span> hash = spread(key.hashCode());
 <span class="hljs-keyword">int</span> binCount = <span class="hljs-number">0</span>;
 <span class="hljs-keyword">for</span> (Node&lt;K,V&gt;[] tab = table;;) &#123;
     Node&lt;K,V&gt; f; <span class="hljs-keyword">int</span> n, i, fh;
     <span class="hljs-keyword">if</span> (tab == <span class="hljs-keyword">null</span> || (n = tab.length) == <span class="hljs-number">0</span>)
         tab = initTable();
     <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ((f = tabAt(tab, i = (n - <span class="hljs-number">1</span>) &amp; hash)) == <span class="hljs-keyword">null</span>) &#123;
         <span class="hljs-comment">// put到空容器中 不需要锁 cas即可</span>
         <span class="hljs-keyword">if</span> (casTabAt(tab, i, <span class="hljs-keyword">null</span>,
                      <span class="hljs-keyword">new</span> Node&lt;K,V&gt;(hash, key, value, <span class="hljs-keyword">null</span>)))
             <span class="hljs-keyword">break</span>;   <span class="hljs-comment">// no lock when adding to empty bin</span>
     &#125;
     <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ((fh = f.hash) == MOVED)
         <span class="hljs-comment">// 如果正在调整大小，则帮助转移</span>
         tab = helpTransfer(tab, f);
     <span class="hljs-keyword">else</span> &#123;
         V oldVal = <span class="hljs-keyword">null</span>;
         <span class="hljs-comment">// 否则就是添加新元素。需要synchronized 获取当前node的锁</span>
         <span class="hljs-keyword">synchronized</span> (f) &#123;
             <span class="hljs-keyword">if</span> (tabAt(tab, i) == f) &#123;
                 <span class="hljs-keyword">if</span> (fh &gt;= <span class="hljs-number">0</span>) &#123;
                     binCount = <span class="hljs-number">1</span>;
                     <span class="hljs-keyword">for</span> (Node&lt;K,V&gt; e = f;; ++binCount) &#123;
                         K ek;
                         <span class="hljs-keyword">if</span> (e.hash == hash &amp;&amp;
                             ((ek = e.key) == key ||
                              (ek != <span class="hljs-keyword">null</span> &amp;&amp; key.equals(ek)))) &#123;
                             oldVal = e.val;
                             <span class="hljs-keyword">if</span> (!onlyIfAbsent)
                                 e.val = value;
                             <span class="hljs-keyword">break</span>;
                         &#125;
                         Node&lt;K,V&gt; pred = e;
                         <span class="hljs-keyword">if</span> ((e = e.next) == <span class="hljs-keyword">null</span>) &#123;
                             pred.next = <span class="hljs-keyword">new</span> Node&lt;K,V&gt;(hash, key,
                                                       value, <span class="hljs-keyword">null</span>);
                             <span class="hljs-keyword">break</span>;
                         &#125;
                     &#125;
                 &#125;
                 <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (f <span class="hljs-keyword">instanceof</span> TreeBin) &#123;
                     Node&lt;K,V&gt; p;
                     binCount = <span class="hljs-number">2</span>;
                     <span class="hljs-keyword">if</span> ((p = ((TreeBin&lt;K,V&gt;)f).putTreeVal(hash, key,
                                                           value)) != <span class="hljs-keyword">null</span>) &#123;
                         oldVal = p.val;
                         <span class="hljs-keyword">if</span> (!onlyIfAbsent)
                             p.val = value;
                     &#125;
                 &#125;
             &#125;
         &#125;
         <span class="hljs-keyword">if</span> (binCount != <span class="hljs-number">0</span>) &#123;
             <span class="hljs-keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD)
                 treeifyBin(tab, i);
             <span class="hljs-keyword">if</span> (oldVal != <span class="hljs-keyword">null</span>)
                 <span class="hljs-keyword">return</span> oldVal;
             <span class="hljs-keyword">break</span>;
         &#125;
     &#125;
 &#125;
 addCount(<span class="hljs-number">1L</span>, binCount);
 <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;
&#125;

<span class="hljs-meta">@SuppressWarnings(&quot;unchecked&quot;)</span>
<span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> &lt;K,V&gt; <span class="hljs-function">Node&lt;K,V&gt; <span class="hljs-title">tabAt</span><span class="hljs-params">(Node&lt;K,V&gt;[] tab, <span class="hljs-keyword">int</span> i)</span> </span>&#123;
 <span class="hljs-keyword">return</span> (Node&lt;K,V&gt;)U.getObjectVolatile(tab, ((<span class="hljs-keyword">long</span>)i &lt;&lt; ASHIFT) + ABASE);
&#125;

<span class="hljs-comment">// 使用cas操作</span>
<span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> &lt;K,V&gt; <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">casTabAt</span><span class="hljs-params">(Node&lt;K,V&gt;[] tab, <span class="hljs-keyword">int</span> i,</span></span>
<span class="hljs-function"><span class="hljs-params">                                 Node&lt;K,V&gt; c, Node&lt;K,V&gt; v)</span> </span>&#123;
 <span class="hljs-keyword">return</span> U.compareAndSwapObject(tab, ((<span class="hljs-keyword">long</span>)i &lt;&lt; ASHIFT) + ABASE, c, v);
&#125;</code></pre>


</blockquote>
<p>md 又是 todo</p>

            </div>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                  <div class="post-meta mr-3">
                    <i class="iconfont icon-category"></i>
                    
                      <a class="hover-with-bg" href="/blog/categories/Java/">Java</a>
                    
                      <a class="hover-with-bg" href="/blog/categories/Java/JUC/">JUC</a>
                    
                  </div>
                
                
                  <div class="post-meta">
                    <i class="iconfont icon-tags"></i>
                    
                      <a class="hover-with-bg" href="/blog/tags/JUC/">JUC</a>
                    
                      <a class="hover-with-bg" href="/blog/tags/%E5%B9%B6%E5%8F%91/">并发</a>
                    
                      <a class="hover-with-bg" href="/blog/tags/%E5%90%8C%E6%AD%A5/">同步</a>
                    
                      <a class="hover-with-bg" href="/blog/tags/1-8%E4%BC%98%E5%8C%96/">1.8优化</a>
                    
                      <a class="hover-with-bg" href="/blog/tags/hash%E4%BC%98%E5%8C%96/">hash优化</a>
                    
                  </div>
                
              </div>
              
                <p class="note note-warning">本博客所有文章除特别声明外，均采用 <a target="_blank" href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" rel="nofollow noopener noopener">CC BY-SA 4.0 协议</a> ，转载请注明出处！</p>
              
              
                <div class="post-prevnext row">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/blog/2021/03/27/Java_%E9%94%81%E5%8D%87%E7%BA%A7/">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">Java_锁升级</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    

    
      <a id="scroll-top-button" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
    

    
  </main>

  <footer class="text-center mt-5 py-3">
  <div class="footer-content">
     <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
  </div>
  

  

  
</footer>

<!-- SCRIPTS -->

  <script  src="https://cdn.staticfile.org/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.staticfile.org/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":200})
    NProgress.start()
    document.addEventListener('DOMContentLoaded', function() {
      window.NProgress && window.NProgress.inc();
    })
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://cdn.staticfile.org/jquery/3.5.1/jquery.min.js" ></script>
<script  src="https://cdn.staticfile.org/twitter-bootstrap/4.5.3/js/bootstrap.min.js" ></script>
<script  src="/blog/js/debouncer.js" ></script>
<script  src="/blog/js/events.js" ></script>
<script  src="/blog/js/plugins.js" ></script>

<!-- Plugins -->


  
    <script  src="/blog/js/lazyload.js" ></script>
  



  



  <script  src="https://cdn.staticfile.org/tocbot/4.12.0/tocbot.min.js" ></script>



  <script  src="https://cdn.staticfile.org/fancybox/3.5.7/jquery.fancybox.min.js" ></script>



  <script  src="https://cdn.staticfile.org/anchor-js/4.3.0/anchor.min.js" ></script>



  <script defer src="https://cdn.staticfile.org/clipboard.js/2.0.6/clipboard.min.js" ></script>





  <script  src="https://cdn.staticfile.org/typed.js/2.0.11/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var title = document.getElementById('subtitle').title;
      
      typing(title)
      
    })(window, document);
  </script>



  <script  src="/blog/js/local-search.js" ></script>
  <script>
    (function () {
      var path = "/blog/local-search.xml";
      var inputArea = document.querySelector("#local-search-input");
      inputArea.onclick = function () {
        searchFunc(path, 'local-search-input', 'local-search-result');
        this.onclick = null
      }
    })()
  </script>















<!-- 主题的启动项 保持在最底部 -->
<script  src="/blog/js/boot.js" ></script>



</body>
</html>
