

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=&#34;auto&#34;>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/blog/img/favicon.png">
  <link rel="icon" type="image/png" href="/blog/img/favicon.png">
  <meta name="viewport"
        content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="description" content="Although things are always not as you wish, but effort will be lucy!">
  <meta name="author" content="melopoz">
  <meta name="keywords" content="">
  <title>AQS - Be your own god.</title>

  <link  rel="stylesheet" href="https://cdn.staticfile.org/twitter-bootstrap/4.5.3/css/bootstrap.min.css" />


  <link  rel="stylesheet" href="https://cdn.staticfile.org/github-markdown-css/4.0.0/github-markdown.min.css" />
  <link  rel="stylesheet" href="/blog/lib/hint/hint.min.css" />

  
    
    
      
      <link  rel="stylesheet" href="https://cdn.staticfile.org/highlight.js/10.1.2/styles/github-gist.min.css" />
    
  

  
    <link  rel="stylesheet" href="https://cdn.staticfile.org/fancybox/3.5.7/jquery.fancybox.min.css" />
  



<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_ba1fz6golrf.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_kmeydafke9r.css">


<link  rel="stylesheet" href="/blog/css/main.css" />

<!-- 自定义样式保持在最底部 -->


  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    var CONFIG = {"hostname":"melopoz.github.io","root":"/blog/","version":"1.8.5","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false},"toc":{"enable":true,"headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"right","visible":"hover","icon":""},"copy_btn":true,"image_zoom":{"enable":true},"lazyload":{"enable":true,"onlypost":false},"web_analytics":{"enable":false,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null}}};
  </script>
  <script  src="/blog/js/utils.js" ></script>
  <script  src="/blog/js/color-schema.js" ></script>
<meta name="generator" content="Hexo 5.4.0"></head>


<body>
  <header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand"
       href="/blog/">&nbsp;<strong>Fluid</strong>&nbsp;</a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/blog/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/blog/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/blog/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/blog/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/blog/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" data-toggle="modal" data-target="#modalSearch">&nbsp;<i
                class="iconfont icon-search"></i>&nbsp;</a>
          </li>
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" href="javascript:">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="banner intro-2" id="background" parallax=true
         style="background: url('/blog/img/default.png') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="page-header text-center fade-in-up">
            <span class="h2" id="subtitle" title="AQS">
              
            </span>

            
              <div class="mt-3">
  
  
    <span class="post-meta">
      <i class="iconfont icon-date-fill" aria-hidden="true"></i>
      <time datetime="2021-01-01 20:46" pubdate>
        2021年1月1日 晚上
      </time>
    </span>
  
</div>

<div class="mt-1">
  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      2.1k 字
    </span>
  

  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      28
       分钟
    </span>
  

  
  
</div>

            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid">
  <div class="row">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-md">
      <div class="container nopadding-md" id="board-ctn">
        <div class="py-5" id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">AQS</h1>
            
            <div class="markdown-body">
              <p>todo </p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/waterystone/p/4920797.html">https://www.cnblogs.com/waterystone/p/4920797.html</a></p>
<h1 id="AQS源码分析"><a href="#AQS源码分析" class="headerlink" title="AQS源码分析"></a>AQS源码分析</h1><p>维护一个 <code>volatile int</code> 变量 <code>state</code> 代表加锁状态</p>
<p>维护一个 队列代表请求锁资源的线程，head持有锁，后边的节点（线程）等待锁</p>
<p>提供一套模板，实现类必须实现以下方法来实现自己加锁解锁的逻辑：</p>
<ul>
<li>boolean tryAcquire(int)：独占式 尝试获取资源，成功则返回true，失败则返回false。</li>
<li>boolean tryRelease(int)：独占式 尝试释放资源，返回值同上。</li>
<li>int tryAcquireShared(int)：共享方式。尝试获取资源。负数表示失败；0表示成功，但没有剩余可用资源；正数表示成功，且有剩余资源。</li>
<li>int tryReleaseShared(int)：共享方式。尝试释放资源，如果释放后允许唤醒后续等待结点返回true，否则返回false。</li>
<li>isHeldExclusively()：该线程是否正在独占资源。只有用到condition才需要去实现它。</li>
</ul>
<p>java同步机制的底层支持(1.6及以上)：LockSupport</p>
<h1 id="LockSupport"><a href="#LockSupport" class="headerlink" title="LockSupport"></a>LockSupport</h1><p>帮助AQS挂起/恢复当前线程</p>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/yonghengzh/p/14280670.html">https://www.cnblogs.com/yonghengzh/p/14280670.html</a></p>
</blockquote>
<p>这个接口声明的方法很像Object的 wait() 和 notify()</p>
<p>void await()  </p>
<p>void awaitUniterruptibl()</p>
<p>boolean await(long, TimeUnit)</p>
<p>long awaitNanos(long)</p>
<p>boolean awaitUntil(Date)</p>
<p>void signal()</p>
<p>void signalAll()</p>
<p>在java层面只是对<code>Unsafe#park()</code>、<code>Unsafe#unpark()</code>的简单封装，在JVM的C语言实现中，每个线程持有一个Parker对象，该Parker对象有三个变量： <code>_counter</code>、``_cond<code>、</code>_mutex<code>，</code>_counter<code>初始值为</code>0`</p>
<h2 id="park"><a href="#park" class="headerlink" title="park()"></a>park()</h2><p>HotSpot源码（部分）：</p>
<pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Parker::park</span><span class="hljs-params">(<span class="hljs-keyword">bool</span> isAbsolute, jlong time)</span> </span>&#123;
	<span class="hljs-keyword">if</span> (Atomic::xchg(<span class="hljs-number">0</span>, &amp;_counter) &gt; <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span>;<span class="hljs-comment">// 获取_counter的值并将其置为0，如果原值为1，则什么也不做</span>
    Thread* thread = Thread::current();
    assert(thread-&gt;is Java_thread(), <span class="hljs-string">&quot;Must be JavaThread&quot;</span>);
    JavaThread *jt = (JavaThread *)thread;
    
    assert(_cur_index == <span class="hljs-number">-1</span>, <span class="hljs-string">&quot;invariant&quot;</span>);
    <span class="hljs-keyword">if</span> (time == <span class="hljs-number">0</span>) &#123;
        _cur_index = REL_INDEX;
        
        <span class="hljs-comment">// 使当前线程加入操作系统的条件等待队列，同时释放mutex锁，并挂起当前线程（也就是 阻塞在这里！！！！！）</span>
        statue = pthread_cond_wait (&amp;_cond[_cur_index], _mutex);<span class="hljs-comment">// pthread_cond_wait 是Linux标准线程库的一个系统调用</span>
        <span class="hljs-comment">// Java中的wait()、await()如果是在Linux中调用，也是通过native调用的这个函数</span>

    &#125; <span class="hljs-keyword">else</span> &#123;
        _cur_index = isAbsolute ? ABS_INDEX : REL_INDEX;
        status = os::Linux::safe_cond_timedwait (&amp;_cond[_cur_index], _mutex, &amp;absTime);<span class="hljs-comment">//??????</span>
        <span class="hljs-keyword">if</span> (status != <span class="hljs-number">0</span> &amp;&amp; WorkAroundNPTLTimedWaitHang) &#123;
            pthread_cond_destroy (&amp;_cond[_cur_index]);
            pthread_cond_init    (&amp;_cond[_cur_index], isAbsolute ? <span class="hljs-literal">NULL</span> : os::Linux::condAttr());
        &#125;
    &#125;
    _cur_index = <span class="hljs-number">-1</span>;
    assert_status(status == <span class="hljs-number">0</span> || status == EINTR || ...)
        ...

    _counter = <span class="hljs-number">0</span>; <span class="hljs-comment">// 计数器再次被置为0</span>
    status = pthread_mutex_unlock(_mutex);<span class="hljs-comment">// 线程释放锁   结束一个park()操作</span>
    
    assert_status(status == <span class="hljs-number">0</span>, status, <span class="hljs-string">&quot;invariant&quot;</span>);
    OrderAccess::fence();
    <span class="hljs-keyword">if</span> (jt -&gt; handle_special_suspend_equivalent_condition()) &#123;
        jt-&gt;java_suspend_self();
    &#125;
&#125;</code></pre>

<ol>
<li>获取当前线程关联的 Parker 对象。</li>
<li>将计数器置为 0，同时检查计数器的原值是否为 1，如果是则放弃后续操作。</li>
<li>在互斥量上加锁。</li>
<li><strong>在条件变量上阻塞</strong>，同时<strong>释放锁</strong>并等待被其他线程唤醒，当被唤醒后，将重新获取锁。</li>
<li>当线程恢复至运行状态后，将计数器的值再次置为 0。</li>
<li>释放锁。<code>最后都要释放锁</code></li>
</ol>
<p>简单说：</p>
<blockquote>
<ul>
<li>如果<code>_counter==0</code>，则线程t暂停（wait）,直到被唤醒（ unpark(t) ）；</li>
<li>如果<code>_counter==1</code>，则将<code>_counter</code>置为<code>0</code>，线程继续运行；</li>
</ul>
</blockquote>
<h2 id="unpark-Thread"><a href="#unpark-Thread" class="headerlink" title="unpark(Thread)"></a>unpark(Thread)</h2><p>HotSpot源码：</p>
<pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Parker::unpark</span><span class="hljs-params">()</span> </span>&#123;
    <span class="hljs-keyword">int</span> s, status ;
    status = pthread_mutex_lock(_mutex);<span class="hljs-comment">// 给当前线程加锁           这里加锁了</span>
    assert (status == <span class="hljs-number">0</span>, <span class="hljs-string">&quot;invariant&quot;</span>);
    s = _counter;
    _counter = <span class="hljs-number">1</span>;<span class="hljs-comment">// 然后将_counter置为1</span>
    <span class="hljs-keyword">if</span> (s &lt; <span class="hljs-number">1</span>) &#123;<span class="hljs-comment">// 然后判断Parker对象关联的线程是否被park(),</span>
        <span class="hljs-comment">// thread might be parked 线程可能已经停止了</span>
        <span class="hljs-keyword">if</span> (_cur_index != <span class="hljs-number">1</span>) &#123;
            <span class="hljs-keyword">if</span> (WorkAroundNPTLTimedWaitHang) &#123;
                status = pthread_cond_signal (&amp;_cond[_cur_index]);<span class="hljs-comment">// 如果被park():通过 pthread_mutex_signal 函数唤醒该线程</span>
                assert (status == <span class="hljs-number">0</span>, <span class="hljs-string">&quot;invariant&quot;</span>);
                status = pthread_mutex_unlock(_mutex);<span class="hljs-comment">// 最后释放锁</span>
                assert (status == <span class="hljs-number">0</span>, <span class="hljs-string">&quot;invariant&quot;</span>);
            &#125; <span class="hljs-keyword">else</span> &#123;
                status = pthread_mutex_unlock(_mutext);
                assert (status == <span class="hljs-number">0</span>, <span class="hljs-string">&quot;invariant&quot;</span>);
                status = pthread_cond_signal (&amp;_cond[_cur_index]);
                assert (status == <span class="hljs-number">0</span>, <span class="hljs-string">&quot;invariant&quot;</span>);
            &#125;
        &#125; <span class="hljs-keyword">else</span> &#123;
            pthread_mutex_unlock(_mutex);
            assert (status == <span class="hljs-number">0</span>, <span class="hljs-string">&quot;invariant&quot;</span>);
        &#125;
    &#125; <span class="hljs-keyword">else</span> &#123;
        pthread_mutex_unlock(_mutex);
        assert (status == <span class="hljs-number">0</span>, <span class="hljs-string">&quot;invariant&quot;</span>);
    &#125;    
&#125;
<span class="hljs-comment">//   --该线程恢复至运行状态(先拿到mutex锁)然后从pthread_cond_wait方法返回--------关联park()源码的pthread_cond_wait函数调用！！！！！</span></code></pre>

<ol>
<li>获取目标线程关联的 Parker 对象（注意目标线程不是当前线程，是Java中unpark(jt)的参数对应的线程）。——jt：JavaThread</li>
<li>在互斥量上加锁。——jt在park()函数中阻塞的时候是释放了锁的</li>
<li>将计数器置为 1。——jt在park()函数开始时将<code>_counter</code>置为了 0，这里置为 1，jt被唤醒之后还会把<code>_counter</code>置为 0</li>
<li>唤醒在条件变量上等待着的线程。——jt调用park()函数并阻塞在了系统函数<code>pthread_cond_wait</code>调用的地方</li>
<li>释放锁。-—–jt继续运行需要拿到对象的mutex锁</li>
</ol>
<p>简单说：</p>
<blockquote>
<ul>
<li>如果线程已暂停，则唤醒它</li>
<li>如果线程正在运行，<code>_counter==0</code>，将<code>_counter</code>置为<code>1</code></li>
<li>如果线程正在运行，<code>_counter==1</code>，do nothing</li>
</ul>
<blockquote>
<p>可以在改线程调用park()之前调用unpark()，效果就是 该线程调用park()的时候不会暂停</p>
</blockquote>
<blockquote>
<p>相比Object的<code>wait()-notify()/notifyAll()</code>来说更准确，可以控制到指定的线程（只要持有该线程Thread的引用）</p>
</blockquote>
</blockquote>
<h1 id="Exclusive独占模式"><a href="#Exclusive独占模式" class="headerlink" title="Exclusive独占模式"></a>Exclusive独占模式</h1><h2 id="加锁"><a href="#加锁" class="headerlink" title="加锁"></a>加锁</h2><h3 id="acquire-int-arg"><a href="#acquire-int-arg" class="headerlink" title="acquire(int arg)"></a>acquire(int arg)</h3><p>独占式获取锁</p>
<pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">acquire</span><span class="hljs-params">(<span class="hljs-keyword">int</span> arg)</span> </span>&#123;
    <span class="hljs-keyword">if</span> (!tryAcquire(arg) &amp;&amp; 				<span class="hljs-comment">// 如果尝试拿锁成功 直接return  没拿到就入队然后阻塞直到获取到锁</span>
        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))<span class="hljs-comment">// 如果尝试拿锁失败，就以独占模式入队</span>
        selfInterrupt();<span class="hljs-comment">// currentThread.interrupt(); </span>
    <span class="hljs-comment">// 调用interrupt()是因为acquireQueued(...)方法可能判断过线程是否被中断，用的是isInterrupted()方法，会清除中断标识，acquireQueued(...)的返回值就代表了线程是否被中断过，所以这里根据这个返回值决定是否需要补充currentThread的中断标识</span>
&#125;</code></pre>

<h4 id="acquireQueued-…-独占模式入队并阻塞获取锁"><a href="#acquireQueued-…-独占模式入队并阻塞获取锁" class="headerlink" title="acquireQueued(…) 独占模式入队并阻塞获取锁"></a>acquireQueued(…) 独占模式入队并阻塞获取锁</h4><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">acquireQueued</span><span class="hljs-params">(<span class="hljs-keyword">final</span> Node node, <span class="hljs-keyword">int</span> arg)</span> </span>&#123;
    <span class="hljs-comment">//标记是否成功拿到资源，默认false</span>
    <span class="hljs-keyword">boolean</span> failed = <span class="hljs-keyword">true</span>;
    <span class="hljs-keyword">try</span> &#123;
        <span class="hljs-keyword">boolean</span> interrupted = <span class="hljs-keyword">false</span>;<span class="hljs-comment">//标记等待过程中是否被中断过</span>
        <span class="hljs-keyword">for</span> (;;) &#123;
            <span class="hljs-keyword">final</span> Node p = node.predecessor();<span class="hljs-comment">// 相当于 p = node.prev  判断了prev是不是null</span>
            <span class="hljs-comment">// 如果当前节点是头节点 且 尝试获取锁成功 就return</span>
            <span class="hljs-keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;<span class="hljs-comment">// node.prev == head 并且 try=true</span>
                setHead(node);<span class="hljs-comment">// 清理引用： head = node; node.thread = null; node.prev = null;</span>
                p.next = <span class="hljs-keyword">null</span>; <span class="hljs-comment">// help GC</span>
                failed = <span class="hljs-keyword">false</span>;
                <span class="hljs-keyword">return</span> interrupted;<span class="hljs-comment">// return false 表示没有中断, acquire()会直接return</span>
            &#125;
            <span class="hljs-comment">// 如果上边try失败了就检查当前线程是否应该park(),如果需要 就检查当前线程是否被中断了（会清空中断标识，然后继续自旋，所以说是不可被中断的，说的就是acquireQueued(...)这个方法！ 只能是最后将原本的中断标识返回出去，由acquire()方法在设置上当前线程的中断标识）</span>
            <span class="hljs-keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp; <span class="hljs-comment">// 检查当前线程是否需要park()</span>
                parkAndCheckInterrupt())
                interrupted = <span class="hljs-keyword">true</span>;
        &#125;
    &#125; <span class="hljs-keyword">finally</span> &#123;
        <span class="hljs-keyword">if</span> (failed)
            cancelAcquire(node);
    &#125;
&#125;</code></pre>

<p>值得一提的是：<code>Condition#await()</code>的调用链中的一环——<code>doAcquireSharedInterruptibly()</code>的大致逻辑也是这样！</p>
<h5 id="addWaiter-node-将当前线程包装成node入队-将curNode通过自旋置为tail"><a href="#addWaiter-node-将当前线程包装成node入队-将curNode通过自旋置为tail" class="headerlink" title="addWaiter(node)将当前线程包装成node入队  将curNode通过自旋置为tail"></a>addWaiter(node)将当前线程包装成node入队  将curNode通过自旋置为tail</h5><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> Node <span class="hljs-title">addWaiter</span><span class="hljs-params">(Node mode)</span> </span>&#123;
    Node node = <span class="hljs-keyword">new</span> Node(Thread.currentThread(), mode);
    <span class="hljs-comment">// Try the fast path of enq; backup to full enq on failure</span>
    Node pred = tail;
    <span class="hljs-keyword">if</span> (pred != <span class="hljs-keyword">null</span>) &#123;
        node.prev = pred;
        <span class="hljs-keyword">if</span> (compareAndSetTail(pred, node)) &#123;
            pred.next = node;
            <span class="hljs-keyword">return</span> node;
        &#125;
    &#125;
    <span class="hljs-comment">// 如果pred==null说明队列需要初始化</span>
    enq(node);<span class="hljs-comment">// 在这里自旋，CAS设置tail为自己</span>
    <span class="hljs-keyword">return</span> node;
&#125;

<span class="hljs-comment">// enq(node) 将node置为tail</span>
<span class="hljs-function"><span class="hljs-keyword">private</span> Node <span class="hljs-title">enq</span><span class="hljs-params">(<span class="hljs-keyword">final</span> Node node)</span> </span>&#123;
    <span class="hljs-keyword">for</span> (;;) &#123;			<span class="hljs-comment">// 自旋                1</span>
        Node t = tail;
        <span class="hljs-keyword">if</span> (t == <span class="hljs-keyword">null</span>) &#123; <span class="hljs-comment">// Must initialize  必须初始化，因为发现队列没有初始化才调用的enq()，这里再验证一下</span>
            <span class="hljs-keyword">if</span> (compareAndSetHead(<span class="hljs-keyword">new</span> Node()))
                tail = head;
        &#125; <span class="hljs-keyword">else</span> &#123;
            node.prev = t;                       <span class="hljs-comment">// 2</span>
            <span class="hljs-keyword">if</span> (compareAndSetTail(t, node)) &#123;    <span class="hljs-comment">// 3  其实就是自选执行这三步 所以就算多个线程在同时跑这三行代码 总会排着队入队的</span>
                t.next = node;<span class="hljs-comment">// 必须把自己设置为tail才行</span>
                <span class="hljs-keyword">return</span> t; <span class="hljs-comment">// 唯一出口</span>
            &#125;
        &#125;
    &#125;
&#125;</code></pre>

<h5 id="shouldParkAfterFailedAcquire-prev-curNode-检查当前线程是否应该park"><a href="#shouldParkAfterFailedAcquire-prev-curNode-检查当前线程是否应该park" class="headerlink" title="shouldParkAfterFailedAcquire(prev, curNode) 检查当前线程是否应该park()"></a>shouldParkAfterFailedAcquire(prev, curNode) 检查当前线程是否应该park()</h5><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">shouldParkAfterFailedAcquire</span><span class="hljs-params">(Node pred, Node node)</span> </span>&#123;
    <span class="hljs-keyword">int</span> ws = pred.waitStatus;
    <span class="hljs-keyword">if</span> (ws == Node.SIGNAL)<span class="hljs-comment">//Signal： -1，指示后续线程需要unpark()</span>
        <span class="hljs-comment">//prev的状态是signal，要求释放以发出信号，所以可以安全地park()</span>
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;
    <span class="hljs-keyword">if</span> (ws &gt; <span class="hljs-number">0</span>) &#123;
        <span class="hljs-comment">// prev对应的线程被cancelled(取消)</span>
        <span class="hljs-keyword">do</span> &#123;
            <span class="hljs-comment">// 跳过prev并重试 直到找到waitStatus&lt;=0的node</span>
            node.prev = pred = pred.prev;
        &#125; <span class="hljs-keyword">while</span> (pred.waitStatus &gt; <span class="hljs-number">0</span>);
        <span class="hljs-comment">// 让(最靠后的、waitStatus&lt;=0的)node作为当前节点的prev</span>
        pred.next = node;
    &#125; <span class="hljs-keyword">else</span> &#123;
        <span class="hljs-comment">/*</span>
<span class="hljs-comment">         * waitStatus must be 0 or PROPAGATE.  Indicate that we</span>
<span class="hljs-comment">         * need a signal, but don&#x27;t park yet.  Caller will need to</span>
<span class="hljs-comment">         * retry to make sure it cannot acquire before parking.</span>
<span class="hljs-comment">         */</span>
        compareAndSetWaitStatus(pred, ws, Node.SIGNAL);
    &#125;
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;
&#125;</code></pre>

<h5 id="parkAndCheckInterrupt-park当前线程并中断"><a href="#parkAndCheckInterrupt-park当前线程并中断" class="headerlink" title="parkAndCheckInterrupt() park当前线程并中断"></a>parkAndCheckInterrupt() park当前线程并中断</h5><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">parkAndCheckInterrupt</span><span class="hljs-params">()</span> </span>&#123;
    LockSupport.park(<span class="hljs-keyword">this</span>);<span class="hljs-comment">// 挂起当前线程</span>
    <span class="hljs-keyword">return</span> Thread.interrupted();<span class="hljs-comment">//最后在查询线程是否被中断，并返回该中断标识（清除掉了，不处理，return出去交给调用方处理）</span>
&#125;</code></pre>



<h2 id="解锁"><a href="#解锁" class="headerlink" title="解锁"></a>解锁</h2><h1 id="Shared共享模式"><a href="#Shared共享模式" class="headerlink" title="Shared共享模式"></a>Shared共享模式</h1><h2 id="加锁-1"><a href="#加锁-1" class="headerlink" title="加锁"></a>加锁</h2><h2 id="解锁-1"><a href="#解锁-1" class="headerlink" title="解锁"></a>解锁</h2>
            </div>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                  <div class="post-meta mr-3">
                    <i class="iconfont icon-category"></i>
                    
                      <a class="hover-with-bg" href="/blog/categories/Java/">Java</a>
                    
                  </div>
                
                
                  <div class="post-meta">
                    <i class="iconfont icon-tags"></i>
                    
                      <a class="hover-with-bg" href="/blog/tags/todo/">todo</a>
                    
                      <a class="hover-with-bg" href="/blog/tags/JUC/">JUC</a>
                    
                  </div>
                
              </div>
              
                <p class="note note-warning">本博客所有文章除特别声明外，均采用 <a target="_blank" href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" rel="nofollow noopener noopener">CC BY-SA 4.0 协议</a> ，转载请注明出处！</p>
              
              
                <div class="post-prevnext row">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/blog/2021/01/01/0_todo_DB_MySQL/">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">Mysql</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/blog/2021/01/01/0_todo_Java_synchronized/">
                        <span class="hidden-mobile">synchronized</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    

    
      <a id="scroll-top-button" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
    

    
  </main>

  <footer class="text-center mt-5 py-3">
  <div class="footer-content">
     <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
  </div>
  

  

  
</footer>

<!-- SCRIPTS -->

  <script  src="https://cdn.staticfile.org/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.staticfile.org/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":200})
    NProgress.start()
    document.addEventListener('DOMContentLoaded', function() {
      window.NProgress && window.NProgress.inc();
    })
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://cdn.staticfile.org/jquery/3.5.1/jquery.min.js" ></script>
<script  src="https://cdn.staticfile.org/twitter-bootstrap/4.5.3/js/bootstrap.min.js" ></script>
<script  src="/blog/js/debouncer.js" ></script>
<script  src="/blog/js/events.js" ></script>
<script  src="/blog/js/plugins.js" ></script>

<!-- Plugins -->


  
    <script  src="/blog/js/lazyload.js" ></script>
  



  



  <script  src="https://cdn.staticfile.org/tocbot/4.12.0/tocbot.min.js" ></script>



  <script  src="https://cdn.staticfile.org/fancybox/3.5.7/jquery.fancybox.min.js" ></script>



  <script  src="https://cdn.staticfile.org/anchor-js/4.3.0/anchor.min.js" ></script>



  <script defer src="https://cdn.staticfile.org/clipboard.js/2.0.6/clipboard.min.js" ></script>





  <script  src="https://cdn.staticfile.org/typed.js/2.0.11/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var title = document.getElementById('subtitle').title;
      
      typing(title)
      
    })(window, document);
  </script>



  <script  src="/blog/js/local-search.js" ></script>
  <script>
    (function () {
      var path = "/blog/local-search.xml";
      var inputArea = document.querySelector("#local-search-input");
      inputArea.onclick = function () {
        searchFunc(path, 'local-search-input', 'local-search-result');
        this.onclick = null
      }
    })()
  </script>















<!-- 主题的启动项 保持在最底部 -->
<script  src="/blog/js/boot.js" ></script>



</body>
</html>
