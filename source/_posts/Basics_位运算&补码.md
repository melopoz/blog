---
title: Java中的位运算
tag:
  - 位运算
  - 二进制
categories: basics
date: 2021/01/01 20:46:25
updated: 2021/01/01 20:46:25
---



## Java中的位运算

`<< / >>`：算数位移，符号位不变

`>>>`：逻辑位移，忽略符号位的含义，直接将所有bit右移

比如：`-2`用8位二进制表示：`1111 1110`

**算数右移**一位得到`-1`(八位二进制：`1111 1111`)

> `1111 1110`, >>1: `0111 1111`, 保留符号位：`1111 1111`，二进制负数求值1)反码:`1000 0000`2）加1:`1000 0001`

**逻辑右移**一位得到127(八位二进制：`0111 1111`)

> `1111 1110`, >>1: `0111 1111` ，忽略第一位本应该表示的符号含义，结果变成了正数，直接计算值 2^7-1。
>
> > 如果用int类型，` -2>>1 = -1`，`-2>>>1 = 2147483647`



## 补码

`补码` 等于 `反码 + 1`

> **反码**：
>
> - 正数的反码：跟原码一样
> - 负数的反码：原码**符号位除外**的其他位  **按位取反**

> **补码**：
>
> - 正数的补码：跟原码一样
> - 负数的补码：**反码加一**

为啥这么设计？。。计算机不会减，只会加。。（当然还会位运算）





那减法怎么办 ？ 

### 减法

 **补码相加**，**再求补码** 得到最终结果

> 比如    `3 - 8`    等于    `3 + (-8)`
>
> | 十进制     | 原码 original code                    | 反码 inverse code                                       | 补码 complement code                      |
> | ---------- | ------------------------------------- | ------------------------------------------------------- | ----------------------------------------- |
> | 3          | 0000... 0011                          | 0000... 0011                                            | 0000... 0011（**I**. 求两个数的补码）     |
> | -8         | **1**000... 1000                      | **1**111... 0111                                        | **1**111... 1000（**I**. 求两个数的补码） |
> | -5（结果） | **1**000... 0101（**IV**再 **加一**） | **1**000... 0100（**III**. 对补码相加的结果**取反码**） | **1**111... 1011（**II**. **补码相加**）  |



>   如果是 `8 - 3`
>
>   | 十进制    | 原码 original code                   | 反码 inverse code | 补码 complement code                     |
>   | --------- | ------------------------------------ | ----------------- | ---------------------------------------- |
>   | 8         | 0000... 1000                         | 0000... 1000      | 0000... 1000（**I**. 求两个数的补码）    |
>   | -3        | **1**000... 0011                     | **1**111... 1100  | **1**111... 1101                         |
>   | 5（结果） | **0**000 0101（**III**对正数求补码） |                   | **0**000... 0101（**II**. **补码相加**） |
>   |           | ↑ 正数的补码是它本身                 |                   | ↑ 溢出 变为正数                          |



一个数学道理：**怎么不通过第三个变量交换两个变量的值？**

```java
int a = 3, b = 5;
a = a + b;// 有两数之和 和 b，就能算出a，我们要把a.val赋给b
b = a - b;// a+b-b 还是a，  现在我们有两数之和(a)和原来的a值，可以求出原来b的值 把原来b.val给a喽
a = a - b;// 完活
```





那计算机怎么计算乘法呢？（其实乘法、除法都是由乘法器来完成）

### 乘法

> 简单点：`a × b`，可以循环`b`次`+a`操作。。。

**位运算**，相当于让变量乘以2^n^。

`a × 5` = `a × 1` + `a × 4`，这样不就是a乘以2^n^了么。直接位运算然后相加。

转成二进制再看就是：

`a` × `0000 ... 0101`，第`0`位是1，第`2`位是1，其他位都是`0`。

所以 `a × 5` = `a <<< 0` + `a <<< 2`



那除法呢。。。

### 除法

乘法可以基于加法进行循环，除法当然也可以基于减法进行循环。

乘法器的除法计算原理：

比如`189 / 5`：  `1011 1101` / `0000 0101`

> 从高位第一个非0位开始， 如果小于除数就增加一位，大于等于就在该位 商1
>
> **1**[011 1101] : `1 < 101`
>
> **10**[11 1101] : `10 < 101`
>
> **101**[1 1101] :  **第5位 商1**  余 0 ，当前结果：`0010 0000`(32)
>
> **0001** [1101] : `1 < 101`
>
> **0001 1**[101] : `11 < 101`
>
> **0001 11**[01] :  **第2位 商1** 余 `10` ，当前结果：`0010 0100`(32+4=36)
>
> > **0000 10**[01] : 这是上边的余数
>
> **0000 100**[1] :  `100 < 101`
>
> **0000 1001** :  **第0位 商1** 余 `100`(4)， 当前结果：`0010 0101`（32+4+1=37）
>
> 所以结果就是： `37 余 4`



这只是整数。。。小数怎么除？





## 掩码 mask

掩码（Mask），通过与目标数字（flag）的按位进行与运算，达到屏蔽指定位的效果。

比如我们可以定义常量`MASK=2`，即二进制`0000 0010`，待操作数`flag=11`，即`0000 1011`，那么： flag & MASK =>

```shell
    00000010 #mask
&   00001011 #flag
    00000010 #result  相当与 用mask规定哪些是有效位（mask为1的bit是有效位）。
```

可以看到，flag除了位1外，其他都被置0了，可以看出掩码的一个作用就是保留掩码为1 的位所对应操作数的位为1，其他位清零。